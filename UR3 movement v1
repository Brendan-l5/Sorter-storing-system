import swift
import roboticstoolbox as rtb
from spatialmath import SE3
from ir_support import UR3
from math import pi
import spatialgeometry as geometry
import numpy as np
from roboticstoolbox import DHLink, DHRobot
import keyboard
import time
from At2.AuboI5.AuboI5 import AuboI5

class PickPlaceRobot:
    def __init__(self):
        self.env = swift.Swift()
        self.env.launch()
        
        self.r1 = UR3()
        self.r1.base = self.r1.base * SE3(0,0,0)
        self.r1.add_to_env(self.env)
        
        self.r2 = AuboI5()
        self.r2.base = self.r2.base * SE3(0,-1,0)
        self.r2.add_to_env(self.env)

        shelf = geometry.Mesh('.venv/At2/shelf.stl', pose=SE3(-0.45, -1.6, 0.85) * SE3.Rx(pi), color=(0.5, 0.3, 0.1, 1), scale=[0.007, 0.002, 0.008])
        self.env.add(shelf)
        
        self.boxes = []
        self.boxes_pos = []
        self.placement_poses = []
        
        self.setup_zones()
        self.create_boxes()
        self.generate_placement_poses()
    
    def setup_zones(self):
        # create first box placement zones
        red_zone = geometry.Cuboid(scale=[0.7, 0.3, 0.01], pose=SE3(0, 0.4, 0.001), color=(1, 0, 0, 0.5))
        self.env.add(red_zone)
        blue_zone = geometry.Cuboid(scale=[0.7, 0.3, 0.01], pose=SE3(0, -0.4, 0.001), color=(0, 0, 1, 0.5))
        self.env.add(blue_zone)
    
    def create_boxes(self):
        # Create coloured boxes to pick and place
        for i in range(6):
            initial_pose = SE3(0.4, -0.3 + i*0.12, 0.05)
            box = geometry.Cuboid(scale=[0.1, 0.1, 0.1], pose=initial_pose, color=(i % 2, 0.0, (i+1) % 2, 1))
            # first box is blue and alternates
            self.env.add(box)
            self.boxes.append(box)
            self.boxes_pos.append(initial_pose)

        # Create shelf boxes for aesthetics
        for i in range(3):
            shelf_box = geometry.Cuboid(scale=[0.1, 0.1, 0.1], pose= SE3(0.15 - i*0.15, -1.6 , 0.08), color=(0, 0.0, 1, 1))
            self.env.add(shelf_box)
    
    def generate_placement_poses(self):
        # generate placement poses
        for i in range(6):
            #alternate between red and blue zones
            if i % 2 == 0:
                place_pose = SE3(-0.2 + i*0.1, -0.4, 0.05)
            else:
                place_pose = SE3(-0.2 + (i-1)*0.1, 0.4, 0.05)
            
            self.placement_poses.append(place_pose)
    
    def UR3_pick_place(self):
        steps = 50
        q0 = (0, -pi/2, -pi/2, -pi/2, pi/2, 0)
        home_pose = self.r1.q

        for i, pose in enumerate(self.boxes_pos):
            pickup_pose = pose * SE3(0.0, 0.0, 0.07) * SE3.Rx(pi)
            air_pose = pose * SE3(-0.1, 0.0, 0.2) * SE3.Rx(pi)
            place_pose = self.placement_poses[i] * SE3(0.0, 0.0, 0.07) * SE3.Rx(pi)
            
            # Solve IK
            q_pickup = self.r1.ikine_LM(pickup_pose, q0=q0, joint_limits=True).q
            q_air = self.r1.ikine_LM(air_pose, q0=q0, joint_limits=True).q
            q_place = self.r1.ikine_LM(place_pose, q0=q0, joint_limits=True).q
            
            # generate trajectory
            traj_pickup = rtb.jtraj(self.r1.q, q_pickup, steps).q
            traj_air = rtb.jtraj(q_pickup, q_air, steps).q
            traj_place = rtb.jtraj(q_air, q_place, steps).q

            for step_idx in range(steps):
                self.r1.q = traj_pickup[step_idx]
                self.env.step(0.02)
                time.sleep(speed)
            
            print("\nMoving to box", i+1, "position:", self.r1.fkine(self.r1.q).t)
            
            for step_idx in range(steps):
                self.r1.q = traj_air[step_idx]
                self.env.step(0.02)
                ee_pose = self.r1.fkine(self.r1.q)
                self.boxes[i].T = ee_pose * SE3(0.0, 0.0, 0.07)
                time.sleep(speed)

            for step_idx in range(steps):
                self.r1.q = traj_place[step_idx]
                self.env.step(0.02)
                ee_pose = self.r1.fkine(self.r1.q)
                self.boxes[i].T = ee_pose * SE3(0.0, 0.0, 0.07)
                time.sleep(speed)
            
            print("Placing box", i+1, "position:", self.r1.fkine(self.r1.q).t)
        # return to home
        traj_home = rtb.jtraj(self.r1.q, home_pose, steps).q

        for step_idx in range(steps):
            self.r1.q = traj_home[step_idx]
            self.env.step(0.02)
            time.sleep(speed)

    def second_placement_poses(self):
        # generate shelf placement poses
        shelf_poses = []
        for i in range(6):
            if i % 2 == 0: #place on shelf
                place_pose = SE3(0.15 - i*0.075, -1.6 , 0.45)
                shelf_poses.append(place_pose)

            else:  #place on conveyor
                place_pose = SE3(0,0,0)  # Dummy pose, change as desired
                shelf_poses.append(place_pose)
        return shelf_poses
    
    def aubo_pick_place(self):
        steps = 50
        q0 = (0, -pi/2, pi/2, 0, pi/2, 0)
        shelf_pose = self.second_placement_poses() 

        for i, pose in enumerate(self.placement_poses):
            if i % 2 == 0:
                pickup_pose = self.placement_poses[i] * SE3(0.0, 0.0, 0.07) * SE3.Rx(pi)
                air_pose = shelf_pose[i] * SE3(0, 0.1, 0.09) * SE3.Rx(pi)
                place_pose = shelf_pose[i] * SE3(0.0, 0.0, 0.07) * SE3.Rx(pi)

                q_pickup = self.r2.ikine_LM(pickup_pose, q0=q0, joint_limits=True, mask=[1,1,1,1,1,1]).q
                q_air = self.r2.ikine_LM(air_pose, q0=q0, joint_limits=True, mask=[1,1,1,1,1,1]).q
                q_place = self.r2.ikine_LM(place_pose, q0=q0, joint_limits=True, mask=[1,1,1,1,1,1]).q

                traj_pickup = rtb.jtraj(self.r2.q, q_pickup, steps).q
                traj_air = rtb.jtraj(q_pickup, q_air, steps).q
                traj_place = rtb.jtraj(q_air, q_place, steps).q

                for step_idx in range(steps):
                    self.r2.q = traj_pickup[step_idx]
                    self.env.step(0.02)
                    time.sleep(speed)

                for step_idx in range(steps):
                    self.r2.q = traj_air[step_idx]
                    self.env.step(0.02)
                    ee_pose = self.r2.fkine(self.r2.q)
                    self.boxes[i].T = ee_pose * SE3(0.0, 0.0, 0.07)
                    time.sleep(speed)
                
                for step_idx in range(steps):
                    self.r2.q = traj_place[step_idx]
                    self.env.step(0.02)
                    ee_pose = self.r2.fkine(self.r2.q)
                    self.boxes[i].T = ee_pose * SE3(0.0, 0.0, 0.07)
                    time.sleep(speed)

            else: #conveyor robot movement
                print("conveyor") # Placeholder for conveyor logic

# Create and run the robot
speed = 0.02
robot = PickPlaceRobot()
robot.UR3_pick_place()
robot.aubo_pick_place()
